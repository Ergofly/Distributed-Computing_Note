# 分布式笔记

沙文杰-18030100427

@ergofly

## 第一讲 概述

### 分布式系统的定义

一个分布式系统由多个通过网络互联的独立自治的计算节点组成，这些计算节点基于消息传递机制进行相互协作，以完成共同的目标。

>计算节点，除了是单个的计算机外，也可以是计算机中的一个进程、线程或虚拟机。

### 分布式系统出现的背景

- 大大小小的计算设备无处不在
- 网络通信技术高速发展、网络规模不断扩大
- 摩尔定律走到瓶颈，免费午餐已经结束
- 越来越多的计算任务需要由分布在不同区域的多个计算节点协作完成

### 分布式系统面临的挑战

- 异构性：各个节点的软硬件差异性很大
- 自治：各节点有自己独立的时钟、独立的内部状态
- 局部视图：节点只能看到整个系统的某个局部视图
- 开放性：节点数目在变动，网络情况在变动
- 可扩展性：节点增加时性能须合理增长
- 故障处理：必须处理网络故障、局部节点故障
- 安全性：保密性、完整性、认证性、隐私、可用性
- 透明性：应用层或用户无法察觉位置、并发、复制、故障、移动、伸缩、性能等变化
- 服务质量保证

### 分布式的一致性

![image-20210701213842325](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-01-21:38:44_image-20210701213842325.png)

> 强一致性的实现是有代价的，大多数情况都不需要严格的强一致性。对于不同的应用场景，应该对一致性有针对的选择，比如金融行业就需要强一致性，而类似于社交媒体就可以只实现弱一致性。
>
> 关于一致性的问题，后面仍会详细讨论。

### 几类分布式系统构架模式

- 客户端-服务器(Client-Server)模式
- 主-从(Master-Slave)模式
- 总线模式
- 对等(Peer-to-Peer)模式
- 混合模式

#### Client-Server模式

Client-Server模式就是常见的客户端发出服务请求，服务器端根据客户端请求参数完成实际运算，并将运算结果返回给客户端的模式，这种模式的问题是客户端和服务器承担的负载的差距很大，往往客户端只需要做很少的部分，但是服务器需要很长时间的计算，当面临高负载的情况时，服务器很容易不堪重负。

这种情况，可以通过使用服务器集群并添加负载均衡服务器来解决。

![image-20210701215210905](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-01-21:52:23_image-20210701215210905.png)

##### 常用的负载均衡策略

- 随机
- 轮询
- 固定权重值
- IP哈希（基于一致性随机散列函数）
- 最少TCP连接数
- 最小响应时间
- 基于各服务器实际负载的动态负载均衡算法

#### Master-Slave模式

主从模式，主节点（Master）负责将总计算任务分解为多个子任务分发给各个从节点完成，主节点监视各个从节点的任务执行情况，将执行失败的任务调度给其它的从节点完成。主节点同时承担了类似于上图中负载均衡器的功能。

### 分布式系统垂直构架

![image-20210701215811016](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-01-21:58:12_image-20210701215811016.png)

现在的大多数应用基本都是基于中间件编写的，而非直接建立在 OS 之上。

#### 中间件

- 为开发者提供高层的编程抽象，屏蔽分布式系统底层的异构性和复杂性
- 提高互操作性和可移植性
- 提供分布式系统的基础设施服务

### 一些常见的分布式系统

- 分布式存储
- Web系统、DNS系统
- 网络文件系统：NFS、HDFS
- P2P资源共享系统：BitTorrent、μTorrent 、eMule
- 区块链、比特币
- 高性能计算系统：Map-Reduce、Spark、TensorFlow

## 第二讲 分布式节点之间的通信技术

### 并发服务技术

常见的并发服务技术：

- 多线程
- 线程池
- 事件驱动（多路复用）

#### 多线程

服务器每收到一个请求，就创建一个服务于该请求的线程来进行服务，有多个请求就创建多个线程。该方案的逻辑简单，每个线程内部的逻辑完全相同。

![image-20210701221036588](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-01-22:10:41_image-20210701221036588.png)

#### 线程池

线程池的示意图：

![image-20210701221749426](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-01-22:17:56_image-20210701221749426.png)

所谓线程池，即维护一个一个能够暂存客户端请求的请求队列，并对线程的创建进行一定约束，约束的条件如下：

线程分为核心线程和临时线程，一般来说，核心线程可以存在很长时间，而临时线程在完成任务后将很快被销毁。线程池技术对核心线程和临时线程的数量进行限制，当有请求入队列时，会有如下的流程：

![image-20210701221708973](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-01-22:17:10_image-20210701221708973.png)

#### 事件驱动技术

使用事件驱动器（选择器）同时监视多个Channel（Socket）某个Channel有事件到来，则将该事件交给服务线程去处理。与Socket相关的常用事件：可读、可写、错误、连接关闭。适合于处理大量短事务的应用场景，比如订单查询。

![image-20210701222136269](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-01-22:21:41_image-20210701222136269.png)

### 远程过程调用RPC

远程过程调用(Remote Procedure Call, RPC)：使应用程序可以像调用本地节点上的过程(子程序) 那样去调用一个远程节点上的子程序。对于被调用者而言也无法区分调用者来自于本地还是远程。RPC将面向过程的通用编程模型扩展到了分布式环境，实现了跨进程、跨语言、跨网络、跨平台的过程调用。

**实现RPC必须要有RPC中间件的支持**

### 远程方法调用RMI

拓展了RPC使得应用程序可以像调用本机上对象的方法一样调用远程主机中对象的方法。

### RPC/RMI中间件

#### RPC/RMI中间件要实现的功能

- 定义并利用Socket服务接口实现了一套调用者和被调用者之间的通信协议。
- **实现了过程参数的序列化、反序列化；过程运算结果的序列化、反序列化。**
- 通信过程中的错误处理
- 过程服务进程(或远程对象)的集中注册与发现（目录服务）
- 远程对象的统一标识和生命周期管理

#### RPC/RMI中间件的工作原理

RPC/RMI中间件在调用者进程中植入stub/proxy模块，stub模块作为远程过程的本地代理，并且暴露与远程过程相同的接口。RPC/RMI中间件在被调用者进程中植入skeleton模块， skeleton作为调用者在远程主机中的代理，代替客户端调用本地方法，并把结果返回给客户端。stub模块与skeleton模块利用Socket进行通信。skeleton模块相当于Client-Server通信模式中的服务器端，要先于客户端运行，并且在某个Socket端口进行监听。

![image-20210701222938479](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-01-22:29:40_image-20210701222938479.png)

#### RPC/RMI中间件的工作示例

![20210701_223901](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-01-22:41:22_20210701_223901.gif)

#### 接口定义语言IDL

适用于支持跨编程语言调用的RPC/RMI中间件，使用独立的语言定义接口，解除对特定语言的依赖，从而实现跨语言的RPC/RMI。

#### 常用的RPC/RMI中间件

- Java RMI：Java的自娱自乐
- **gRPC：Google的RPC中间件，高效，开源，跨语言**
- Google Protocol Buffers：一种对象序列化标准和开发库
- Dubbo：淘宝开源中间件，Java

### 仅支持点对点通信的缺点

![image-20210701225252580](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-01-22:52:54_image-20210701225252580.png)

- 在复杂分布式系统中，仅支持点对点通信会使得不同节点之间的通信关系十分复杂，耦合度高。
- 数据生产节点需要记录多个消费节点的标识，消费节点需要记录多个生产节点的标识。
- 可扩展性差：每增加一个生产者或消费者会对多个节点产生影响。
- 容错性差：节点失效后，会丢失失效期间的数据；生产者、消费者速度不匹配时也会丢失数据。

**解决上述问题可以添加一个中介节点**

![image-20210701225412324](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-01-22:54:14_image-20210701225412324.png)

数据生产者只向中介节点发送数据；数据消费者只向中介者订阅自己感兴趣的数据。提高了容错性：中介节点具有数据缓存功能，部分节点失效、或者通信双方速度暂时不匹配时数据也不会丢失。提高了可扩展性：增加消费节点对生成节点无影响；增加同类型的生成节点，对消费节点无影响。

### 基于消息中间件的通信技术

在点对点通信的解决方案中，为避免中介节点称为系统的瓶颈，其实际上也可以是一个集群，也即消息队列中间件。

#### 消息中间件（MOM）

提供了一种分布式消息队列服务，使得节点之间可以实现基于消息的形式灵活的异步通信。

所谓异步，即发送方可以在任意时刻发出消息，不必等待接收方上线，更不必等待消息发送成功再做下一步工作， 接收方不必以阻塞方式等待消息的到来。

#### MOM支持的两种通信模式

##### 消息队列通信模式

- 在生产者和消费者之间建立的满足先进先出的消息队列
- 一个队列可以有多个生产者，也可以有多个消费者。
- 消息队列中的消息一旦被某个消费者取走，该消息就从队列中删除。
- 出队的消息按照某种负载均衡策略发送给特定的消费者。
- 高级队列模式：带优先级的队列；支持持久性的队列

##### 主题/订阅通信模式

- 支持向一个特定的消息主题发布消息。 
- 多个订阅同一主题的消费者可以同时接收发布到该消息主题的消息
- 可以灵活地实现广播、组播等多对多通信模式

#### 基于 MOM 实现通信的优点

- **实现异步通信，减少系统响应时间，提高吞吐量**
- **实现分布式节点之间的解耦**
- 保证消息的可靠递交，实现最终一致性
- 绝大多数 MOM 都有持久缓存功能，接收者失效重启后可以重新获取所需的消息
- 实现广播、组播和多对多通信
- 实现流量削峰和流量控制
- 支持 Push 模型和 Pull 模型

#### 常用的MOM中间件

- ActiveMQ：由 Apache 出品，完全兼容JMS（Java Message Service）

  > ActiveMQ客户端的三种接收方式
  >
  > - 阻塞接收
  > - 轮询接收
  > - 回调接收 （通知接收）

- RabbitMQ：采用Erlang语言实现的AMQP协议的消息中间件，最初起源于金融系统。

- RocketMQ：阿里 的开源产品，用 Java 语言实现；在阿里内部被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理等场景。

- Apache Kafka：提供完全分布式架构，与Apache的其他平台如Hadoop、Apache Storm、Spark、Flink等集成方便。

- ZeroMQ：号称史上最快的消息队列，基于C语言开发。

## 第三讲 分布式存储

### 分布式存储系统要达到的目标

- 提高数据存储容量：让**总体存储容量**随节点增多而增大（水平可扩展）；
- 提高数据吞吐量：让**总体吞吐量**随节点增多而增大（水平可扩展），比如将一个大文件切片存储在多个主机内，要获取该文件时即可同时从多个主机同时进行下载；
- 提高可靠性 / 可用性：部分节点故障时数据不丢失 / 部分节点失效不影响整个系统的数据读写（容错性）；
- （可选）降低数据访问延时：用户可以从地理位置上最接近的节点获取数据（如 CDN，Content Delivery Network，即内容分发网络）；
- 提高分布式数据处理系统的运行效率。

### 分布式存储使用的基本手段

复制和分区

#### 复制

在多个不同的节点上保存相同数据的多个副本（replica）。

复制提供了冗余，如果一些节点不可用，剩余的节点仍然可以提供数据服务。多个节点上存储副本也可以提高数据吞吐率、改善访问性能。

同时也带来了问题：硬件成本提高，在数据变更时保障多数据副本之间的之间的一致性是个复杂问题。

##### 复制的策略

**基于领导者的复制**，也称为主动/被动(active/passive)复制、主/从(master/slave)复制，或主/备(primary/backup)复制。

基本思想：

- 副本之一被指定为领导者(主库)；其他副本被指定为追随者（从库）
- 客户端要向数据存储系统写入数据时，它必须将请求发送给领导者；领导者将新数据写入本地存储，同时也会将数据变更发送给所有的追随者。
- 当客户想要从数据存储系统读取数据时，它可以向领导者或追随者查询。
- **适合于读多写少的应用场景。**

![image-20210702151306818](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-02-15:13:08_image-20210702151306818.png)

**使用主从复制时，主库应该选择中间级别的数据更新命令如数据库更新日志中的数据更新指令**，它既不像高级别数据更新命令如SQL命令那般需要重新解释（耗费资源），也不像低级别命令如CPU机器指令那般效率太低。

###### 数据库更新日志

数据副本节点一般分两步处理数据写入(或复制)请求：先将更新操作信息追加到更新日志，再根据操作参数更新本地存储系统）。

在传统数据库中的用途：

- 更新本地存储系统失败后，还可以根据日志重试失败的更新操作。（例如计算机本身Fail-Stop-Recover了）
- 更新失败后也便于本地存储系统恢复到之前的一致性状态
- 保存了整个更新历史，便于出现错误时进行问题回溯。
- 某些设计中，写入请求成功追加到日志就可以应答用户。这样只在日志文件尾部追加，提高了写入速度

**在分布式存储中的新用途**：

- 便于落后的追随者追赶上领导者的最新状态。

- 便于实现分布式事务

- > 基于数据库更新日志的同步
  >
  > ![image-20210702153404442](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-02-15:37:34_2021-07-02-15:34:06_image-20210702153404442.png)
  >
  > 长时间运行后，更新日志会变得过于冗长，并且占用很多非易失存储器的存储空间。
  >
  > 如果将某个时间点的本地存储系统完整的保存在非易失存储器中，形成系统的一个快照。快照对应时间点之前的更新日志就可以删除了。
  >
  > 进行同步时，如果一个追随者的状态落后了很多，在追赶领导者时可以先把一个快照完整地复制到自己的本地存储系统，然后再根据快照点之后的更新日志追赶至最新状态。

##### 复制的方法

###### 单主复制

- 一个领导者多个追随者。
- 优点：实现相对简单。大多数应用场景都是读多写少。
- 缺点：主库即是性能瓶颈，又是单点故障节点(Single point of failure)
- 为提高容错性，自动将某个从库切换为主库时会面临脑裂问题。

###### 多主复制

- 系统中有多个主库接受写入操作。每个主库都将该数据更改转发给所有其他节点。每个领导者同时扮演其他领导者的追随者。
- 应用场景：多数据中心之间的复制；协同文档编辑。
- 优点：写入性能高。
- 缺点：写入冲突问题、多副本一致性问题解决方案太复杂。

###### 无主复制

- 没有主库从库的概念。
- 客户端直接将写入请求发送到到各个副本；或者客户端将写入发送给某个节点，由该节点充当代理节点向其他节点转发写入请求。

##### 同步复制和异步复制

###### 同步复制

- 领导者写入自己的存储器，并且接收到所有跟随者已经成功更新本地存储的应答后再向用户返回成功写入应答。
- 优点：**更容易实现副本之间的强一致性**。
- 缺点：写入速度慢；一个节点失效会使整体写入功能失败。

![image-20210702151924638](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-02-15:19:26_image-20210702151924638.png)

###### 异步复制

- 领导者自己写入成功后立即向向用户返回成功应答，不等待其他跟随者的应答消息。
- 优点：写入速度快；容错性好。
- 缺点：保持多副本一致性复杂，**只能保持最终一致性**。

![image-20210702152110786](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-02-15:21:12_image-20210702152110786.png)

##### 多副本分布式存储的一致性问题

###### 数据一致性模型

多个客户端在读写数据时，分布式存储系统为客户端提供的关于数据外在表现的保证。是客户端和多副本分布式存储系统之间一种服务约定。

###### 产生一致性问题的原因

- 多个客户端“同时”对分布式存储系统进行读写
- 分布式节点之间的网络不可靠：丢包、延迟、断裂、乱序
- 部分存储节点会失效
- 节点的局部时钟不同步

###### 一致性的分类

**强一致性（线性一致性/原子一致性）**

在客户端看来，分布式存储系统的外在表现和单副本存储系统的外在表现完全一致。（类似于多个线程访问同一个寄存器）

任意客户端看到的所有针对分布式系统的操作(读、写等原子操作)按全局一致的顺序排列（线性化），并且该排序满足多个操作在时间维度上的实际发生先后顺序。

> ![image-20210702154428207](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-02-15:44:29_image-20210702154428207.png)
>
> 一个读操作读取到了一个更新后的变量值，发生在该读操作之后的读操作只能读出相同的值或者更新版本的值，不能读出旧版本的值。

**顺序一致性**

任意客户端看到的所有针对分布式系统的操作(读、写等原子操作)按全局一致的顺序排列（线性化），同一个客户端发出的多个操作的顺序与该全局一致排序并不矛盾。

**因果一致性**

不同客户端看到的所有针对分布式系统的操作(读、写等原子操作)排序不一定一致，但该排序不违背操作发生的因果关系。

**最终一致性**

在分布式系统停止更新时，最终所有读操作都可以获得最新版本的数据。

###### 一致性的指导意义

分布式系统的一致性保证越强，客户端应用程序越容易编写；一致性保证越弱，客户端程序逻辑就越复杂。

##### CAP定理

**Consistensy(一致性)**：不同节点上数据的强一致性

**Partition Tolerance(割断容忍性)**：允许部分节点与其它节点断裂

**Availability(可用性)**：发出的请求在规定时间段内总能返回结果（请求响应延时短，可用性高；否则可用性低）

**CAP定理：在设计分布式系统时，三者只能取其二，不能三者兼得。**

![image-20210702155727913](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-02-15:58:00_2021-07-02-15:57:36_image-20210702155727913.png)

#### 分区

将一个大型数据文件(或数据库)拆分成较小的子集（称为分区partition或切片shard），再将不同的分区指派给不同的节点。

分区提高了吞吐率（访问数据的负载被分散到多个节点上）和可靠性（鸡蛋被放到多个篮子里），方便了对数据的并行处理。

带来的问题：跨区查询（分布式索引问题）；合理、动态分区问题（大数据如何拆分）；负载均衡问题（各个切片如何合理地分配给不同节点）。

##### 数据分区的目标

将数据和查询负载均匀分布在各个节点上，避免出现偏斜(skew)和热点(hot spot)问题。分区方式要兼顾跨区查询问题。

##### 数据分区的基本方法

###### 根据主键范围进行分区

数据集合中每个元素（块、对象、记录）都可以找到一个主键，根据主键的连续范围进行分区。

各个主键范围分区一般都是非均匀分布的，不同的主键范围分区分配给不同的物理存储节点，在特定分区进行分裂或合并时会产生数据移动。

优点：按主键进行连续查询很方便。

缺点：在主键范围非均匀分布时必须建立全局索引以记录数据分区和存储节点的对应关系。**一般要专门指定一个节点维护全局索引，该节点是中心节点**。

###### 根据主键的哈希值进行分区（桶哈希）

> **理想哈希函数：**
>
> 相同的输入会产生相同的输出；输入输出的对应完全是随机的。对于给定的输入字符串，函数输出“随机”落在值域空间的某个点上。两个输入值即便只相差1个bit，输出值可能相差很远。

将整个哈希空间均匀分成k个区间（k个桶），每个存储节点负责一个哈希区间（桶）。计算新插入数据元素主键的哈希值，然后计算该哈希值落入了哪个桶，最后将该数据元素分配给该桶所对应的存储节点。

优点：可以在一定程度上避免了偏斜和热点问题。无须全局索引，因而也无须中心节点。

缺点：基于主键进行连续范围查询效率极低。在物理存储节点较少时仍然会出现偏斜和热点问题（可以采用虚拟节点的方法进行缓解）。**桶的个数改变时会产生大量数据移动。**

###### 根据主键的哈希值进行分区（一致性哈希）

找一个普通的理想哈希函数HASH，将该HASH函数的值域空间首尾相接做成一个环。假定每个存储节点（每个节点负责一个桶）都有一个唯一标识（例如针对每个节点生成一个随机数作为其标识；或用其IP地址）：$ID_1,ID_2,...,ID_n$。每个节点的唯一标识作为输入计算其HASH函数输出，并将其输出值映射到环上，会产生n个映射点。节点$ID_i$所负责的桶就是顺时针方向$ID_i$的前一个映射点到自己的哈希区间。

![image-20210702161717688](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-02-16:17:19_image-20210702161717688.png)

**一致性哈希解决了桶哈希的数据移动问题。在使用一致哈希算法后，桶数量的改变平均只需要对K/n 个关键字重新映射，其中K是关键字的数量，n是桶的数量。每个桶中映射的关键字数量保持均衡，当增加新的桶时，部分关键字被放入新桶中，但不会出现部分关键字在两个旧桶之间转移的情况。**

![image-20210702162321781](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-02-16:23:26_image-20210702162321781.png)

#### 分布式系统的案例-分布式文件系统

##### 分布式文件系统的概念

将分布式系统中多个节点的存储资源整合在一起，向用户/应用程序呈现统一的存储空间和文件系统目录树。用户无需关心数据存储在哪个节点上。

##### 分布式文件系统特点

- 由分布式文件系统中间件自动处理文件的分块、存储节点选择和副本备份等问题。
- 统一名字空间：每个文件、目录在分布式文件系统中都有统一的、唯一的名字。
- 锁管理机制：对多个用户的并发读写具有锁控制措施。
- 副本备份机制：一般都支持利用多副本提高数据容错性。
- 数据存取方式：随机写入或追加式写入
- 安全机制：对读写文件有权限控制措施
- 可扩展性：支持通过增加节点扩充存储容量
- 高吞吐率：多副本可以提高数据吞吐率

##### HDFS分布式文件系统

HDFS 遵循主/从架构，由单个NameNode(NN) 和多个DataNode(DN) 组成。

![image-20210702163157420](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-02-16:31:59_image-20210702163157420.png)

- 高容错：采用数据多副本方案，部分硬件的损坏不会导致全部数据的丢失。

- 高吞吐量：支持多个客户端同时与多数据节点直接通信，实现了高吞吐量的数据访问。（不同于低延迟数据访问）

- 大文件支持：HDFS 适合于大文件的存储，文档的大小应该是GB 到TB 级别的。

  > 为什么不适合大量小文件存储？
  >
  > NameNode将文件系统的元数据存放在内存中，因此存储的文件数目受限于 NameNode的内存大小。HDFS中每个文件、目录、数据块占用150Bytes。如果存放的文件数目过多的话会占用很大的内存。
  >
  > HDFS适用于高吞吐量，而不适合低时间延迟的访问。如果同时存入大量的小文件会花费很长的时间

- 简单一致性模型：HDFS 更适合于一次写入多次读取(write-once-read-many) 的访问模型。支持将内容追加到文件末尾，不能从文件任意位置新增数据。

###### HDFS维护的两张表

**文件名-数据块表**

![image-20210702163351397](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-02-16:33:57_image-20210702163351397.png)

**数据块-物理节点表**

![image-20210702163406565](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-02-16:34:16_image-20210702163406565.png)

###### HDFS客户端的读流程

- 客户端将读请求发送给NameNode，读请求参数中包含了文件名、偏移量和长度。
- NameNode根据文件名、偏移量查找自己内存中“文件名—数据块对应表”和“数据块—物理节点对应表”，并将包含目标数据块的数据节点IP列表发送给客户端。
- 客户端从数据节点IP列表中选择“最近的”的数据节点，并与该节点建立Socket连接直接读取数据。

###### HDFS客户端的写流程

- 客户端将新建文件请求发送给NameNode，NameNode根据负载均衡策略选择3个数据节点，并将这些节点IP地址返回给客户端。
- 客户端将这3个数据节点构成一个流水线，将第一个数据库的数据流写入流水线。
- 第一个数据块写入成功后客户端再向NameNode获取下一个数据块对应的3个数据节点。

### 三种分布式存储系统的区别

*注：本答案参考[块存储、文件存储、对象存储这三者的本质差别是什么？ - 知乎](https://www.zhihu.com/question/21536660)* *和* *[虚拟座谈会：有关分布式存储的三个基本问题](https://link.zhihu.com/?target=http%3A//www.infoq.com/cn/articles/virtual-forum-three-basic-issues-about-distributed-storage)*

#### 本质区别

除了三者使用的不同的网络存储协议的区别，**最本质的区别是使用这些存储系统的“用户”不同**。

块存储的“用户”是能够读写块设备的软件系统，如Linux；对象存储的“用户”是计算机软件；文件系统的“用户”是自然人。

#### 块存储

块存储的典型设备是磁盘、硬盘。块存储读写速度快，但查询速度慢，不方便管理。块存储可以通过了 Raid 与 LVM 等手段，对数据提供保护，有一定的安全性。接口方面以 SCSI 为例，主要接口有 Read/Write/Read Capacity/Inquiry ......

#### 文件存储

文件存储的典型设备是FTP、NFS服务器。文件存储读写速度慢，查询速度中等，好在人可以直接使用，管理起来方便。但是这种文件树结构也带来了效率低、安全性差的缺点。接口方面以 NFS 为例，文件相关的接口包括：LOOKUP/ACCESS/READ/WRITE/CREATE/REMOVE/RENAME ......，文件夹相关的接口包括：MKDIR/RMDIR/READDIR ......

#### 对象存储

对象存储的典型设备是内置大容量硬盘的分布式服务器。读写速度和块存储相当，查询速度也快。虽然不利于人直接管理，但是程序容易管理。对象存储和文件存储的区别不大，存储的都是一样的东西，但是**抛弃了统一的命名空间和层次结构**，使得扩展性更强，也较为安全。接口方面以 S3 为例，主要接口有 PUT/GET/DELETE ....，和文件和对象存储相比，没有随机读写的接口，和文件存储相比，没有目录树的概念。

## 第四讲 MapReduce和Spark程序设计

### MapReduce

MapReduce计算框架分为三个部分，Map、聚集混洗（包含二次分区）、Reduce。

![image-20210702164401062](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-02-16:44:02_image-20210702164401062.png)

#### 三个阶段

##### Map 阶段

第一阶段并行。将输入文件划分为多个分区，每个分区交给一个独立的 Map 子任务进行处理；

##### 聚集混洗阶段

各 Map 子任务输出的 <k, v> 数组按 key 聚集，聚集成数组 `A={<k1, [v1, v2, ...]>,<k2, [v3, v4, ...]>}` 的形式；

##### Reduce 阶段

第二阶段并行，将聚集后的 A 重新分区，每个分区都交给一个独立的 Reduce 子任务处理。Reduce 子任务根据输入生成一系列 <k, v> 对。

#### MapReduce计算实例-单词计数

![image-20210702164823639](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-02-16:48:25_image-20210702164823639.png)

### Spark

#### Spark的基本概念

Spark 是快速、通用、可扩展的分布式计算平台（引擎），有丰富的语言、API、类库、部署模式和数据源的支持，能够进行批处理、流处理和复杂的业务分析。

Spark让应用层把一个宏观的分布式计算任务抽象为一个 DAG（有向无环图。图中的顶点是数据，弧是对数据进行的操作），然后可以根据该 DAG 来将一些计算子任务进行合并，实现数据流动量的下降。

Spark Core 引擎在运行前会将宏观的计算任务生成为 DAG 并进行优化，优化的结果就是将我们原先的宏观任务切分为可并行的子任务。

![image-20210702165809729](https://gitee.com/ergofly/image-bed/raw/master/Images/2021-07-02-16:59:30_2021-07-02-16:58:11_image-20210702165809729.png)

#### Spark编程

##### 分布式弹性数据集 RDD

RDD可以被简单地将其视作一个分布式存储的“大数组”（甚至可以有 TB 那么大）。 

一个分布式计算任务涉及到的不同 RDD 之间存在依赖关系， RDD 的每次转换都会生成一个新的依赖关系，RDD 及其之间的依赖关系就组成了 DAG 。使用Spark只需关心如何由一个 RDD 通过 Spark 提供的算子转化为另一个 RDD 即可（算子也可以在应用层自定义），而无需关心底层逻辑。Spark 编程，就是定义 RDD 之间的转换过程。

这一转换过程由Spark提供的RDD算子来实现.。

##### 常用的RDD算子

详见此[文档](https://github.com/heibaiying/BigData-Notes/blob/master/notes/Spark_Transformation%E5%92%8CAction%E7%AE%97%E5%AD%90.md)。

#### Spark计算实例-单词计数

```python
from pysparkimport SparkConf,SparkContext
conf= SparkConf().setMaster("local").setAppName(“wordcount")
sc= SparkContext(conf=conf)
textData= sc.textFile("./readme.txt")
splitData= textData.flatMap(lambda line:line.split(" "))
flagData= splitData.map(lambda word:(word,1))
countData= flagData.reduceByKey(lambda x,y:x+y)
countData.saveAsTextFile("./result")
```

